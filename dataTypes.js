// Значение в JavaScript всегда относится к данным определённого типа.
// Например, это может быть строка или число.
// Есть восемь основных типов данных в JavaScript.
// Переменная в JavaScript может содержать любые данные.
// В один момент там может быть строка, а в другой – число:
// Языки программирования, в которых такое возможно, называются «динамически типизированными».
// Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

// ПРИМИТИВНЫЕ ТИПЫ ДАННЫХ (хуй изменишь)(содержат 1 значение)

// Числа
// const i = 1; // в десятиричном виде
// const j = 0xBE; // в 16-ричном виде
// const k = 0777; // в восьмеричном виде
// const f = 0b0101010; // в двоичном виде
// NaN означает ошибку в математической операции.
// Если в длинном алгебраическом выражении есть NaN, то всё выражение станет тождественным NaN.
// isNaN(Nan) //true
// isFinite(value) – false //if value: Infinity/ -Infinity/ NaN

//`` === 0

// Буква е заменяет нули:
// 1е9 = 1 000 000 000
// 2.5е9 = 2.5 * 1 000 000 000 = 2.500 000 000
// 2.5е-9 = 2.5 / 1 000 000 000 = 0. 000 000 002 5


// 0.1 + 0.2 = 0.300000000000004 (косяк формата IEEE 754 - PHP, Java, C, Perl, Ruby, JS)

// +number.toFixed(n) – обрезает число до количества n цифр после нуля. 1 < n < 21.

// Object.is(a, b) – очень точное сравнение, которое работает с NaN. (=== не работает с NaN.)

// + как и Number(value) явно преобразовывает в Number
// Достать число из строки? parseInt, parseFloat
// let line = '100px';
// parseInt(line)


// Строки

// Строки – это массивы символов.
// Если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}
// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки.(обычные кавычки только с \n)
let str = `Smoke`
str.length // 5. This is no function!
// Содержимое строки в JavaScript нельзя изменить.
// Можно создать новую строку и записать её в ту же самую переменную вместо старой.


// разбивает строку на массив её элементов
// let chars = Array.from(str);
// chars[1] = m
// chars[2] = o

str[1] // m
str.toUpperCase() // SMOKE
str.toLowerCase() //smoke
str[1].toUpperCase() //Smoke
str[0].toLowerCase() // smoke
str.includes(`mok`) // true – поиск по подстроке
str.substring(2, 3) // ok (lu4she str.slice)
str.codePointAt(2) // код для символа `o`
// Про юникод отдельно. Лучше подгуглить, там фокусы всякие со смайликами и прочим.

// Булевый тип

// true – любое число, кроме нуля. Истина.
// false  - 0. Ложно.
// ! – высший приоритет из трёх, «не»
// && - средний приоритет из трёх «и» (возвращает первое попавшееся ложное либо последнее истинное)
// || - низший приоритет из трёх «или» (возвращает первое попавшееся истинное либо последнее ложное)


// null отдельный тип. Означает «неизвестно»
// undefined отдельный тип. Означает «значение переменной не присвоено».
// Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

// ССЫЛОЧНЫЕ ТИПЫ ДАННЫХ (Тебе лишь бы изменить. Но тут можно.)
// Объекты
let mark = new Object(); // синтаксис "конструктор объекта"
let presentation = {};  // синтаксис "литерал объекта"
let example = {
    1: `a`,
    stels: `b`,
    'Peter Pedigrue': `rat`,
}
delete example.stels // удалит свойство stels
const constanta = {
    "strategy of win": null,
    "strategy of false": true,
}
    // можно изменить поля. Нельзя изменить объект в целом.
    // если свойства из нескольких слов. то доступ к ним будет через []. Также можно получить доступ к вычисляемому полю.
constanta['strategy of win'] = false;
delete constanta['strategy of false'];
// let user = {
//     name: "John",
//     age: 30
// };

// let key = prompt("Что вы хотите узнать о пользователе?", "name");

// // доступ к свойству через переменную
// alert( user[key] ); // John (если ввели "name")

// Свойства объекта могут называться как угодно! даже let, enum, array. И все преобразуются в строку!
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"
// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.
// let fruit = 'apple';
// let bag = {
//     [fruit + 'Computers']: 5 // bag.appleComputers = 5
// };
// сокращения:
// function makeUser(name, age) {
//     return {
//         name, // то же самое, что и name: name
//         age   // то же самое, что и age: age
//         // ...
//     };
// }
// или
// let user = {
//     name,  // тоже самое, что и name:name
//     age: 30
// };

// Прототипное наследование в другой презентации.

// Если обратиться к свойству, которого не существует, вернётся undefined
// let user = {};
// alert( user.noSuchProperty === undefined ); // true означает "свойства нет
// Поэтому есть специальный оператор "in"
// "key" in object
// пример:
// let user = { name: "John", age: 30 };
// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует
// Если без кавычек, то мы указываем переменную, в которой хранится имя свойства
// let user = { age: 30 };
// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной key
// "IN" особенно нужен, чтобы проверить, есть ли свойство со значением undefined

// Для перебора всех свойств объекта используется цикл for..in.
// for (key in object) {
//     // тело цикла выполняется для каждого свойства объекта
// }
// пример
// let user = {
//     name: "John",
//     age: 30,
//     isAdmin: true
// };
//
// for (let key in user) {
//     // ключи
//     console.log( key );  // name, age, isAdmin
//     // значения ключей
//     console.log( user[key] ); // John, 30, true
// }

// Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, как, например, let key здесь.
//
//     Кроме того, мы могли бы использовать другое имя переменной. Например, часто используется вариант "for (let prop in obj)".

// Когда перебираешь свойства объекта, свойства с целочисленным именем будут упорядочиваться по возрастанию.
// Чтобы такого избежать, надо добавить к ним какой-нибудь символ.
// let codes = {
//     "+49": "Германия",
//     "+41": "Швейцария",
//     "+44": "Великобритания",
//     // ..,
//     "+1": "США"
// };
//
// for (let code in codes) {
//     console.log( +code ); // 49, 41, 44, 1
// }

// ПРИВЕДЕНИЕ ТИПОВ

alert приводит значение к строке
Также к строке приводит явно String(value). При этом true => "true", NaN => "NaN"
Любой тип данных + строка будет преобразован в строку.

К числу приводят любые математические операции, кроме + // !!!
Также к числу приводит явно +value. Работает, как Nubmer(value)
Также к числу приводит явно Number(value). При этом
undefined => NaN
null => 0
true / false => 1 / 0
string => Пробельные символы по краям обрезаются.
          Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
          При ошибке результат NaN.

К булевому типу
    Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
    Все остальные значения становятся true.
Также к булевому типу приводит явно Boolean(value). При этом, '' === false, ' '/ '0' !== false


// ПРЕОБРАЗОВАНИЕ ОБЪЕКТОВ

Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования.

Преобразование объектов в примитивы вызывается автоматически многими встроенными функциями и операторами,
которые ожидают примитив в качестве аргумента.
Существует всего 3 типа преобразований (хинтов):
    "string" (для alert и других операций, которым нужна строка)
    "number" (для математических операций)
    "default" (для некоторых операций)

В спецификации явно указано, какой хинт должен использовать каждый оператор.
    И существует совсем немного операторов, которые не знают, что ожидать, и используют хинт со значением "default".
    Обычно для встроенных объектов хинт "default" обрабатывается так же, как "number".
    Таким образом, последние два очень часто объединяют вместе.

Алгоритм преобразований к примитивам следующий:
    Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
    Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
    Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.

На практике довольно часто достаточно реализовать только obj.toString() как «универсальный» метод для всех типов преобразований,
    возвращающий «читаемое» представление объекта, достаточное для логирования или отладки.